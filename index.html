<!DOCTYPE html>
<html lang="en">
  <!-- 
  --- FILE: index.html ---
  Combines Trail Effect, Mobile Touch Logic, and the User's exact <model-viewer> code.
  Updated: 
  - Carousel Loader Delay: Changed from 1000ms (1s) to 300ms (0.3s) as requested.
-->
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ggg</title>

    <!-- CSP: Permissive settings -->
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; script-src * 'unsafe-inline' 'unsafe-eval' blob:; img-src * data: blob:; media-src * data: blob:; style-src * 'unsafe-inline'; object-src * data: blob:; font-src * data:;"
    />

    <!-- TAILWIND CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- LOAD MODEL-VIEWER COMPONENT -->
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"
    ></script>

    <style>
      /* --- CUSTOM FONT DEFINITION --- */
      @font-face {
        font-family: "Programme";
        src: url("Programme-Regular/Programme-Regular.eot");
        src: url("Programme-Regular/Programme-Regular.eot?#iefix")
            format("embedded-opentype"),
          url("Programme-Regular/Programme-Regular.woff2") format("woff2"),
          url("Programme-Regular/Programme-Regular.woff") format("woff");
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }

      /* --- GLOBAL RESET --- */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: #ffffff;
        font-family: "Programme", sans-serif;
        overflow: hidden;
        font-size: 1rem;
        cursor: none !important;
        overscroll-behavior: none;
        touch-action: none;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        cursor: none !important;
      }

      /* --- CUSTOM CURSOR --- */
      #custom-cursor {
        position: fixed;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 10000;
        font-family: "Programme", sans-serif;
        font-weight: 400;
        font-size: 2rem;
        line-height: 1;
        color: #ffffff;
        mix-blend-mode: difference;
        transform: translate(-50%, -50%);
        transition: transform 0.15s cubic-bezier(0.23, 1, 0.32, 1);
        will-change: transform, top, left;
        text-align: center;
        width: 3rem;
        height: 3rem;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* STRICTLY HIDE CURSOR ON MOBILE */
      body.is-mobile #custom-cursor {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }

      /* --- EXPAND BUTTON (Hidden/Replaced) --- */
      #expand-btn {
        display: none;
      }

      /* --- MAIN LAYOUT --- */
      #canvas {
        position: relative;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
        background-color: #ffffff;
        transition: opacity 0.4s ease;
      }

      /* --- ABOUT PAGE WRAPPER --- */
      #about-page {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        background-color: #ffffff;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.4s ease;
      }

      #about-page.active {
        display: block;
        opacity: 1;
      }

      /* --- MODEL VIEWER STYLES --- */
      :not(:defined) > * {
        display: none;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        background-color: #ffffff;
        outline: none;
      }

      model-viewer > #ar-prompt {
        position: absolute;
        left: 50%;
        bottom: 60px;
        animation: elongate 20s infinite ease-in-out alternate;
        display: none;
        z-index: 50;
      }

      model-viewer[ar-status="session-started"] > #ar-prompt {
        display: block;
      }

      model-viewer > #ar-prompt > img {
        animation: circle 20s linear infinite;
      }

      .progress-bar {
        display: block;
        width: 33%;
        height: 10%;
        max-height: 2%;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate3d(-50%, -50%, 0);
        border-radius: 25px;
        box-shadow: 0px 3px 10px 3px rgba(0, 0, 0, 0.5),
          0px 0px 5px 1px rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.9);
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 50;
      }

      .progress-bar.hide {
        visibility: hidden;
        transition: visibility 0.3s;
      }

      .update-bar {
        background-color: #000;
        width: 0%;
        height: 100%;
        border-radius: 25px;
        float: left;
        transition: width 0.3s;
      }

      #ar-button {
        background-image: url(ar_icon.png);
        background-repeat: no-repeat;
        background-size: 20px 20px;
        background-position: 12px 50%;
        background-color: #fff;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        white-space: nowrap;
        bottom: 16px;
        padding: 0px 16px 0px 40px;
        font-family: "Programme", sans-serif;
        font-size: 14px;
        color: #4285f4;
        height: 36px;
        line-height: 36px;
        border-radius: 18px;
        border: 1px solid #dadce0;
        z-index: 50;
        cursor: none !important;
      }

      #ar-button:active {
        background-color: #e8eaed;
      }

      #ar-button:focus {
        outline: none;
      }

      #ar-button:focus-visible {
        outline: 1px solid #4285f4;
      }

      @keyframes circle {
        from {
          transform: translateX(-50%) rotate(0deg) translateX(50px) rotate(0deg);
        }
        to {
          transform: translateX(-50%) rotate(360deg) translateX(50px)
            rotate(-360deg);
        }
      }

      @keyframes elongate {
        from {
          transform: translateX(100px);
        }
        to {
          transform: translateX(-100px);
        }
      }

      /* --- NAVIGATION --- */
      nav {
        position: fixed;
        top: 5px;
        left: 5px;
        right: 5px;
        padding: 0;
        z-index: 9999;
        color: #ffffff;
        mix-blend-mode: difference;
        display: grid;
        grid-template-columns: max-content max-content max-content;
        column-gap: 6rem;
        align-items: start;
        justify-content: start;
        transition: all 0.5s ease;
      }

      @media (max-width: 800px) {
        nav {
          grid-template-columns: 1fr;
          column-gap: 1rem;
          row-gap: 0.5rem;
          justify-content: space-between;
          display: flex;
          flex-wrap: wrap;
        }
        #nav-center {
          display: none;
        }
      }

      .nav-text {
        font-size: 1rem;
        pointer-events: auto;
      }

      #nav-center {
        position: static;
        pointer-events: auto;
        white-space: nowrap;
        overflow: visible;
        text-align: left;
      }

      #nav-center a {
        text-decoration: none;
        color: inherit;
        cursor: pointer;
      }

      /* SCALE BUTTON (Desktop) */
      #nav-scale {
        position: absolute;
        right: 0;
        top: 0;
        display: none;
        cursor: pointer;
        pointer-events: auto;
        background-color: #000;
        color: #fff;
        padding: 2px 6px;
        font-size: 1rem;
        mix-blend-mode: normal;
        user-select: none;
        z-index: 0;
      }

      #nav-scale .front {
        position: relative;
        z-index: 2;
        mix-blend-mode: difference;
      }

      #nav-scale .back {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #000000;
        opacity: 0;
        transition: opacity 0.1s ease;
        pointer-events: none;
        will-change: opacity;
      }

      #nav-scale:hover .back {
        opacity: 1;
      }

      /* --- FOOTER --- */
      footer {
        position: fixed;
        bottom: 5px;
        left: 5px;
        right: 5px;
        z-index: 9999;
        pointer-events: none;
        color: #ffffff;
        mix-blend-mode: difference;
        font-size: 1rem;
        line-height: 1.15;
      }

      #footer-text {
        transition: opacity 0.3s ease;
      }

      /* --- ABOUT TEXT --- */
      .about-bottom-text {
        position: absolute;
        bottom: 5px;
        left: 5px;
        right: 5px;
        font-size: 1rem;
        line-height: 1.1;

        display: block; /* Flow layout */

        color: #ffffff;
        mix-blend-mode: difference;
        z-index: 40;
        pointer-events: none;
      }

      .about-bio {
        text-align: justify;
        display: block;
        margin-bottom: 0.25rem;
      }

      .about-skills-list {
        display: block;
        text-align: right;
      }

      .skill-item {
        display: inline-block;
        margin-left: 6rem;
      }

      @media (max-width: 800px) {
        .about-bottom-text {
          text-align: left;
          line-height: 1.3;
          bottom: 0;
          padding-bottom: calc(5px + env(safe-area-inset-bottom));
        }

        .about-bio {
          text-align: left;
          line-height: 1.3;
          margin-bottom: 0.25rem;
        }
        .about-skills-list {
          text-align: left;
          line-height: 1.3;
        }
        .skill-item {
          margin-left: 0;
          margin-right: 2rem;
        }
      }

      .about-center-text {
        position: absolute;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        max-width: 42rem;
        padding: 2rem;
        z-index: 40;
        pointer-events: none;
        color: #ffffff;
        mix-blend-mode: difference;
        line-height: 1.1;
      }

      /* --- CANVAS HELPERS --- */
      #canvas.hidden-canvas {
        opacity: 0;
        pointer-events: none;
      }

      #helper-text {
        pointer-events: none;
        z-index: 5;
        transition: opacity 0.5s ease;
      }

      /* --- TRAIL IMAGES --- */
      .trail-image {
        position: absolute;
        width: 200px;
        height: 133px;
        border-radius: 0;
        overflow: hidden;
        transform-origin: center center;
        transform: translate(-50%, -50%);
        transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1),
          opacity 0.3s ease, left 0.5s cubic-bezier(0.23, 1, 0.32, 1),
          top 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        box-shadow: none;
        z-index: 4000;
        user-select: none;
        background-color: #000;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      .trail-image.no-transition {
        transition: none !important;
      }

      .slide-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        pointer-events: none;
        -webkit-user-drag: none;
        transition: transform 0s;
        /* No global rotation - handled by class .rotate-90 */
      }

      /* Video styling */
      video.slide-image {
        height: 94%;
        top: 3%;
        object-fit: contain;
        background-color: black;
      }

      /* Special class for rotated videos */
      .rotate-90 {
        transform: rotate(90deg) scale(1.5) !important;
      }

      body:not(.zoomed-active) .trail-image:hover {
        transform: translate(-50%, -50%) scale(1.15);
        z-index: 4010;
      }

      .trail-image.zoomed {
        z-index: 5000;
        transform: translate(-50%, -50%)
          translate(var(--tx, 0px), var(--ty, 0px)) scale(var(--target-scale));
      }

      .trail-image.faded {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s ease-out;
      }

      #backdrop {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.95);
        z-index: 50;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      body.zoomed-active #backdrop {
        opacity: 1;
        pointer-events: auto;
      }

      /* --- ANIMATIONS --- */
      .animate-enter-right {
        animation: slideInRight 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
      }
      .animate-exit-left {
        animation: slideOutLeft 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
      }
      .animate-enter-left {
        animation: slideInLeft 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
      }
      .animate-exit-right {
        animation: slideOutRight 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
      }

      @keyframes slideInRight {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0%);
        }
      }
      @keyframes slideOutLeft {
        from {
          transform: translateX(0%);
        }
        to {
          transform: translateX(-100%);
        }
      }
      @keyframes slideInLeft {
        from {
          transform: translateX(-100%);
        }
        to {
          transform: translateX(0%);
        }
      }
      @keyframes slideOutRight {
        from {
          transform: translateX(0%);
        }
        to {
          transform: translateX(100%);
        }
      }

      /* --- LOADING SCREEN (Global) --- */
      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: white;
        z-index: 99999;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        pointer-events: auto;
        transition: opacity 0.5s ease;
      }

      .loading-rect {
        width: 5px;
        height: 5px;
        border: 1px solid black;
        background: transparent;
        transition: background-color 0.2s ease;
      }

      .loading-rect.filled {
        background-color: black;
      }

      /* --- SLIDE LOADER (Inverted for Black Background) --- */
      .slide-loader {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        gap: 5px;
        z-index: 6000;
        pointer-events: none;
      }

      .slide-loader .loading-rect {
        border-color: white;
        animation: loader-fill 1s infinite;
      }

      .slide-loader .loading-rect:nth-child(1) {
        animation-delay: 0s;
      }
      .slide-loader .loading-rect:nth-child(2) {
        animation-delay: 0.2s;
      }
      .slide-loader .loading-rect:nth-child(3) {
        animation-delay: 0.4s;
      }
      .slide-loader .loading-rect:nth-child(4) {
        animation-delay: 0.6s;
      }

      @keyframes loader-fill {
        0%,
        100% {
          background-color: transparent;
        }
        50% {
          background-color: white;
        }
      }
    </style>
  </head>
  <body>
    <!-- LOADING SCREEN -->
    <div id="loading-screen">
      <div class="loading-rect"></div>
      <div class="loading-rect"></div>
      <div class="loading-rect"></div>
      <div class="loading-rect"></div>
    </div>

    <!-- 1. CUSTOM CURSOR -->
    <div id="custom-cursor">!</div>

    <!-- 3. TOP NAVIGATION -->
    <nav>
      <div id="nav-home" class="nav-text">gigergrafik</div>
      <!-- Email Link -->
      <div id="nav-center" class="nav-text">
        <a href="mailto:giger@grafik.ch" target="_blank">giger@grafik.ch</a>
      </div>
      <div id="nav-about" class="nav-text">über</div>

      <!-- Scale Button -->
      <div id="nav-scale" class="nav-text">
        <span class="front">scale</span>
        <span class="back">image</span>
      </div>
    </nav>

    <!-- 4. FOOTER -->
    <footer>
      <div id="footer-text"></div>
    </footer>

    <!-- 5. ABOUT PAGE WITH MODEL-VIEWER -->
    <div id="about-page">
      <!-- model-viewer logic directly integrated -->
      <model-viewer
        src="scans/untitled1.glb"
        ar
        ar-modes="webxr scene-viewer quick-look"
        camera-controls
        orbit-sensitivity="1.5"
        interpolation-decay="100"
        tone-mapping="neutral"
        poster="poster.webp"
        shadow-intensity="0"
        exposure="0.98"
      >
        <div class="progress-bar hide" slot="progress-bar">
          <div class="update-bar"></div>
        </div>
      </model-viewer>

      <div class="about-center-text"></div>
      <div class="about-bottom-text">
        <div class="about-bio">
          I’m a designer who loves exploring the experimental side of visual
          communication, always searching for new ways to break, stretch, and
          rethink the boundaries of what design can be. My practice is shaped by
          curiosity—both visually and technically. I’m drawn to unusual
          aesthetics, generative ideas, and graphic systems that challenge
          conventional expectations. Whether it’s through layouts that subvert
          traditional hierarchy, typography that behaves more like a living
          organism, or mixing analog and digital processes, I enjoy pushing my
          work into territories that feel a little unfamiliar and a little
          unpredictable. Activistic graphic design is also an important part of
          my interests. I see design not only as a craft, but as a tool for
          dialogue and reflection. I’m fascinated by how visual language can
          amplify underrepresented voices, provoke thought, or make people aware
          of the structures that surround them. I like to observe the world with
          a critical eye and let those impressions influence the way I
          create—subtly or boldly, depending on the project. On the technical
          side, I’m increasingly curious about open-source alternatives and new
          creative workflows. I don’t use them heavily yet, but I’m motivated to
          learn more about how open systems, community-built tools, and
          unconventional software can expand the way I design. The idea that
          creative tools can be transparent, adaptable, and shared freely is
          something that inspires me and fits well with my experimental
          approach.
        </div>
        <div class="about-skills-list">
          <span class="skill-item">Skills:</span>
          <span class="skill-item">InDesign</span>
          <span class="skill-item">Illustrator</span>
          <span class="skill-item">Photoshop</span>
          <span class="skill-item">Coding</span>
          <span class="skill-item">TouchDesigner</span>
          <span class="skill-item">Cavalry</span>
          <span class="skill-item">Photography</span>
        </div>
      </div>
    </div>

    <!-- 6. MAIN CANVAS -->
    <div id="canvas">
      <div
        id="helper-text"
        class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center"
      >
        <p class="text-[1rem] font-normal text-gray-500">
          move mouse to drop images. click to expand & slide :))
        </p>
      </div>
      <div id="backdrop"></div>
    </div>

    <!-- --- JAVASCRIPT --- -->
    <script>
      console.log("Application initializing...");

      // --- CONFIGURATION ---
      const CONFIG = {
        boxWidth: 200,
        boxHeight: 133,
        minDist: 120,
        maxImages: 8,
        navZoneHeight: 100,
        mobileScale: 0.75,
        mobileMinDist: 60,
        mobileBoxWidth: 120,
        mobileBoxHeight: 80,
        edgeGap: 0,
      };

      // --- ASSETS ---
      const GALLERIES = [];
      const projectFolders = [
        "bitwusst",
        "experimente",
        "fotografik",
        "layout2",
        "london",
        "musikplakat",
        "paris",
        "prepress",
      ];

      for (let i = 0; i < projectFolders.length; i++) {
        const folder = projectFolders[i];
        const arr = [`bilder/${folder}/${folder}cover.webp`];
        for (let j = 1; j <= 27; j++) {
          arr.push(`bilder/${folder}/${j}.webp`);
        }
        GALLERIES.push(arr);
      }

      const PROJECT_NAMES = [
        "BITWUSST?",
        "ARCHIVE",
        "BITGRAMM",
        "24 HOURS",
        "WILD LONDON",
        "MASTER CONCERTS",
        "PERDUS",
        "GREETINGS LUCERNE!",
      ];
      const CAPTIONS = [
        "BITWUSST? acts as an interface between scientific theory and visual communication. Comprising a detailed report and an accompanying poster, the project traces a spectrum of consciousness extending from atoms to algorithms. Grounded in Integrated Information Theory and Panpsychism, it investigates whether awareness is a fundamental property of matter itself or merely a result of complex processing. The work questions if feeling necessitates biological flesh, or if digital sensors can generate genuine presence. Ultimately, BITWUSST? encourages a quiet reflection on the nature of reality, bridging the organic, the mineral, and the digital.",
        "A sandbox for visual curiosity. Ranging from TouchDesigner jams to video experiments, this is where I hunt for weird textures and unexpected aesthetics. It’s a space to play, break things, and embrace happy accidents—treating software like a messy material to see what strange visuals come out the other side.",
        "Serving as a visual evolution of the BITWUSST? project, this work translates the initial theoretical inquiry into a material outcome. Centered around a newspaper publication and a photogram series, it recontextualizes the neural networks generated during the development phase, placing them in dialogue with analog studies of form. The imagery captures a spectrum of materials—ranging from organic elements like leaves, grass, and seeds to synthetic artifacts like cables. By treating both the botanical and the technical with the same darkroom process, the work creates a unified texture where the roots of nature and the wires of technology become visually indistinguishable.",
        "One day, one class, countless stories. For the interdisciplinary project 24 Hours, I created a system that translates time into structure. Using a strict grid of 24 rows and 60 columns—representing every hour and minute—the design dictates the narrative flow. Images stream through the book, physically displacing and reorganizing the typography around them. It is a visual study of time, rhythm, and the dynamic tension between content and form.",
        "London is usually mapped by human needs, but for this collaborative publication, we shifted the narrative. Exploring the city through the senses of 88 different species—from the peregrine falcon surveying the Thames to the urban fox navigating by scent—the project challenges our anthropocentric view of the metropolis. Each student adopted the perspective of a specific animal, visualizing how landmarks become obstacles and streets become hunting grounds. The resulting book is a collective portrait of a hidden London, documenting the impossible but necessary attempt to see the city through eyes other than our own.",
        "HSLU Master Concerts For this campaign, I used TouchDesigner to translate the concept of resonance into a graphic system. The typography is rendered as a dispersing point cloud, creating a visual noise that implies frequency and vibration. This aesthetic—hovering between structure and chaos—captures the dynamic atmosphere of the concerts, providing a fluid identity for both the poster and the motion design.",
        "In a city where Baroque grandeur collides with social invisibility, Perdus explores the rift between power and marginalization. Anchored at the Place des Victoires, the project weaves together visual scans, historical context, and social critique into a silent dialogue on decay, dignity, and inequality. It challenges the viewer to perceive Paris not merely as a museum of architecture, but as a stage for the pressing social realities of our time.",
        "Bypassing the scenic Mount Pilatus and the Chapel Bridge, this work focuses on Emil Manser. The goal was to capture the imperfect side of Lucerne: raw, loud, and authentic. Using Python, I built a custom generator that reconstructed Manser’s portrait entirely from the text of his famous street signs. The result is a digital synthesis of street philosophy and code—a postcard from the real city, far removed from the tourist gaze.",
      ];

      // --- STATE ---
      const state = {
        lastX: 0,
        lastY: 0,
        count: 0,
        hasMoved: false,
        isZoomed: false,
        zoomedElement: null,
        currentGalleryIndex: 0,
        currentSlideIndex: 0,
        isAnimating: false,
        aboutActive: false,
        collisionEdges: {
          top: false,
          bottom: false,
          left: false,
          right: false,
        },
        isMobile: false,
        isLoading: true,
        currentMobileScale: 1,
        anchorEdge: null,
        currentScale: 1,
        currentTx: 0,
        currentTy: 0,
        // Slide loading request counter to prevent race conditions
        slideRequestId: 0,
      };

      // --- DOM REFERENCES ---
      const canvas = document.getElementById("canvas");
      const aboutPage = document.getElementById("about-page");
      const backdrop = document.getElementById("backdrop");
      const helperText = document.getElementById("helper-text");
      const navCenter = document.getElementById("nav-center");
      const navHome = document.getElementById("nav-home");
      const navAbout = document.getElementById("nav-about");
      const navScale = document.getElementById("nav-scale");
      const footerText = document.getElementById("footer-text");
      const footerEl = document.querySelector("footer");
      const customCursor = document.getElementById("custom-cursor");
      const expandBtn = document.getElementById("expand-btn");

      // --- MOBILE INIT ---
      const checkMobile = () => {
        if (window.innerWidth < 800) {
          state.isMobile = true;
          document.body.classList.add("is-mobile");
          helperText.innerText = "Drag finger to draw. Tap box to expand.";
        }
      };
      checkMobile();
      window.addEventListener("resize", checkMobile);

      // --- FIX NAV WIDTH ---
      function fixNavWidth() {
        if (!state.isMobile) {
          navCenter.style.width = "auto";
          const width = navCenter.offsetWidth;
          navCenter.style.width = width + 1 + "px";
        }
      }
      document.fonts.ready.then(fixNavWidth);
      window.addEventListener("resize", fixNavWidth);

      // --- PRELOAD LOGIC ---
      function preloadAllCovers() {
        let loadedCount = 0;
        const total = GALLERIES.length;
        const dots = document.querySelectorAll(".loading-rect");

        let finished = false;
        function finishLoading() {
          if (finished) return;
          finished = true;
          const screen = document.getElementById("loading-screen");
          if (screen) {
            screen.style.opacity = "0";
            setTimeout(() => screen.remove(), 500);
          }
          state.isLoading = false;
        }

        function updateLoader() {
          loadedCount++;
          const ratio = loadedCount / total;
          const dotsToFill = Math.ceil(ratio * 4);
          dots.forEach((dot, idx) => {
            if (idx < dotsToFill) dot.classList.add("filled");
          });
          if (loadedCount >= total) finishLoading();
        }

        setTimeout(finishLoading, 3000);

        GALLERIES.forEach((gallery) => {
          const src = gallery[0];
          const img = new Image();
          img.onload = updateLoader;
          img.onerror = () => {
            const vid = document.createElement("video");
            vid.onloadeddata = updateLoader;
            vid.onerror = updateLoader;
            vid.src = src.replace(".webp", ".mp4");
          };
          img.src = src;
        });
      }
      preloadAllCovers();

      // --- MODEL VIEWER EVENT LOGIC ---
      const onProgress = (event) => {
        const progressBar = event.target.querySelector(".progress-bar");
        const updatingBar = event.target.querySelector(".update-bar");
        if (updatingBar) {
          updatingBar.style.width = `${event.detail.totalProgress * 100}%`;
        }
        if (event.detail.totalProgress === 1) {
          if (progressBar) progressBar.classList.add("hide");
          event.target.removeEventListener("progress", onProgress);
        } else {
          if (progressBar) progressBar.classList.remove("hide");
        }
      };
      const modelViewer = document.querySelector("model-viewer");
      if (modelViewer) {
        modelViewer.addEventListener("progress", onProgress);
      }

      // --- HELPER FUNCTIONS ---
      const updateInfo = (boxId) => {
        const projName = PROJECT_NAMES[boxId - 1] || "";
        if (navCenter) navCenter.innerText = projName;
        const caption = CAPTIONS[boxId - 1] || "";
        if (footerText) footerText.innerText = caption;
      };

      const resetInfo = () => {
        if (navCenter)
          navCenter.innerHTML =
            '<a href="mailto:giger@grafik.ch" target="_blank">giger@grafik.ch</a>';
        if (footerText) footerText.innerText = "";
      };

      const resetTrail = () => {
        const allImages = document.querySelectorAll(".trail-image");
        allImages.forEach((img) => img.remove());
        state.count = 0;
        state.hasMoved = false;
        state.lastX = 0;
        state.lastY = 0;
        helperText.style.opacity = "1";
      };

      const preloadNeighbors = (galleryIdx, currentSlideIdx) => {
        const gallery = GALLERIES[galleryIdx];
        const nextIdx = (currentSlideIdx + 1) % gallery.length;
        const prevIdx = (currentSlideIdx - 1 + gallery.length) % gallery.length;
        new Image().src = gallery[nextIdx];
        new Image().src = gallery[prevIdx];
      };

      function loadMedia(
        src,
        container,
        onSuccess,
        onError,
        className = "slide-image"
      ) {
        const img = document.createElement("img");
        img.className = className;
        img.onload = () => {
          container.appendChild(img);
          if (onSuccess) onSuccess(img);
        };
        img.onerror = () => {
          const vidSrc = src.replace(".webp", ".mp4");
          const vid = document.createElement("video");
          vid.className = className;
          vid.muted = true;
          vid.loop = true;
          vid.autoplay = true;
          vid.playsInline = true;

          vid.onloadeddata = () => {
            container.appendChild(vid);
            vid.play().catch((e) => console.log("Auto-play prevented", e));
            if (onSuccess) onSuccess(vid);
          };

          vid.onerror = () => {
            const vidRot = document.createElement("video");
            vidRot.className = className + " rotate-90";
            vidRot.muted = true;
            vidRot.loop = true;
            vidRot.autoplay = true;
            vidRot.playsInline = true;

            vidRot.onloadeddata = () => {
              container.appendChild(vidRot);
              vidRot.play().catch((e) => console.log("Auto-play prevented", e));
              if (onSuccess) onSuccess(vidRot);
            };

            vidRot.onerror = () => {
              if (onError) onError();
            };
            vidRot.src = src.replace(".webp", "-90.mp4");
          };

          vid.src = src.replace(".webp", ".mp4");
        };
        img.src = src;
      }

      // --- NAVIGATION EVENTS ---
      navAbout.addEventListener("click", () => {
        resetInfo();
        if (state.isZoomed) {
          state.isZoomed = false;
          state.zoomedElement = null;
          document.body.classList.remove("zoomed-active");
          navScale.style.display = "none";
        }
        canvas.classList.add("hidden-canvas");
        state.aboutActive = true;
        setTimeout(() => {
          aboutPage.classList.add("active");
          setTimeout(() => (aboutPage.style.opacity = "1"), 10);
        }, 400);
      });

      navHome.addEventListener("click", () => {
        state.aboutActive = false;
        aboutPage.style.opacity = "0";
        setTimeout(() => {
          aboutPage.classList.remove("active");
          canvas.classList.remove("hidden-canvas");
          resetTrail();
        }, 400);
      });

      // --- INFINITE SCALE LOGIC ---
      navScale.addEventListener("click", () => {
        if (!state.zoomedElement || state.isMobile) return;

        const el = state.zoomedElement;
        const rect = el.getBoundingClientRect();
        const footerRect = footerEl.getBoundingClientRect();
        const limitBottom = footerRect.top;
        const limitRight = window.innerWidth;

        const isTop = Math.abs(rect.top) < 2;
        const isBottom = Math.abs(rect.bottom - limitBottom) < 2;
        const isLeft = Math.abs(rect.left) < 2;
        const isRight = Math.abs(rect.right - limitRight) < 2;

        if ((isTop && isBottom) || (isLeft && isRight)) {
          if (isTop && isBottom && isLeft && isRight) return;
          if (isTop && isBottom) return;
          if (isLeft && isRight) return;
        }

        let anchor = state.anchorEdge;
        if (isTop && isLeft) anchor = "top-left";
        else if (isTop && isRight) anchor = "top-right";
        else if (isBottom && isLeft) anchor = "bottom-left";
        else if (isBottom && isRight) anchor = "bottom-right";
        else if (isTop) anchor = "top";
        else if (isBottom) anchor = "bottom";
        else if (isLeft) anchor = "left";
        else if (isRight) anchor = "right";
        state.anchorEdge = anchor;

        let ratios = [];
        const currentW = rect.width;
        const currentH = rect.height;
        const spaceTop = rect.top;
        const spaceBottom = limitBottom - rect.bottom;
        const spaceLeft = rect.left;
        const spaceRight = limitRight - rect.right;

        if (anchor === "top") {
          if (spaceBottom > 1)
            ratios.push({ r: (currentH + spaceBottom) / currentH, type: "h" });
          const sideSpace = Math.min(spaceLeft, spaceRight);
          if (sideSpace > 1)
            ratios.push({
              r: (currentW + 2 * sideSpace) / currentW,
              type: "w_sym",
            });
        } else if (anchor === "bottom") {
          if (spaceTop > 1)
            ratios.push({ r: (currentH + spaceTop) / currentH, type: "h" });
          const sideSpace = Math.min(spaceLeft, spaceRight);
          if (sideSpace > 1)
            ratios.push({
              r: (currentW + 2 * sideSpace) / currentW,
              type: "w_sym",
            });
        } else if (anchor === "left") {
          if (spaceRight > 1)
            ratios.push({ r: (currentW + spaceRight) / currentW, type: "w" });
          const vertSpace = Math.min(spaceTop, spaceBottom);
          if (vertSpace > 1)
            ratios.push({
              r: (currentH + 2 * vertSpace) / currentH,
              type: "h_sym",
            });
        } else if (anchor === "right") {
          if (spaceLeft > 1)
            ratios.push({ r: (currentW + spaceLeft) / currentW, type: "w" });
          const vertSpace = Math.min(spaceTop, spaceBottom);
          if (vertSpace > 1)
            ratios.push({
              r: (currentH + 2 * vertSpace) / currentH,
              type: "h_sym",
            });
        } else if (anchor === "top-left") {
          if (spaceBottom > 1)
            ratios.push({ r: (currentH + spaceBottom) / currentH, type: "h" });
          if (spaceRight > 1)
            ratios.push({ r: (currentW + spaceRight) / currentW, type: "w" });
        } else if (anchor === "top-right") {
          if (spaceBottom > 1)
            ratios.push({ r: (currentH + spaceBottom) / currentH, type: "h" });
          if (spaceLeft > 1)
            ratios.push({ r: (currentW + spaceLeft) / currentW, type: "w" });
        } else if (anchor === "bottom-left") {
          if (spaceTop > 1)
            ratios.push({ r: (currentH + spaceTop) / currentH, type: "h" });
          if (spaceRight > 1)
            ratios.push({ r: (currentW + spaceRight) / currentW, type: "w" });
        } else if (anchor === "bottom-right") {
          if (spaceTop > 1)
            ratios.push({ r: (currentH + spaceTop) / currentH, type: "h" });
          if (spaceLeft > 1)
            ratios.push({ r: (currentW + spaceLeft) / currentW, type: "w" });
        } else {
          const minSpace = Math.min(
            spaceTop,
            spaceBottom,
            spaceLeft,
            spaceRight
          );
        }

        ratios = ratios.filter((item) => item.r > 1.005);
        ratios.sort((a, b) => a.r - b.r);

        if (ratios.length === 0) {
          state.currentScale = state.initialScale;
          state.currentTx = 0;
          state.currentTy = 0;
          el.style.setProperty("--target-scale", state.initialScale);
          el.style.setProperty("--tx", "0px");
          el.style.setProperty("--ty", "0px");
          return;
        }

        const best = ratios[0];
        const growthFactor = best.r;
        const nextScale = state.currentScale * growthFactor;
        state.currentScale = nextScale;

        let dX = 0;
        let dY = 0;
        const rawGrowthW = currentW * (growthFactor - 1);
        const rawGrowthH = currentH * (growthFactor - 1);

        // Compensation Translation based on Anchor
        if (anchor === "top") dY = rawGrowthH / 2;
        else if (anchor === "bottom") dY = -rawGrowthH / 2;
        else if (anchor === "left") dX = rawGrowthW / 2;
        else if (anchor === "right") dX = -rawGrowthW / 2;
        else if (anchor === "top-left") {
          dX = rawGrowthW / 2;
          dY = rawGrowthH / 2;
        } else if (anchor === "top-right") {
          dX = -rawGrowthW / 2;
          dY = rawGrowthH / 2;
        } else if (anchor === "bottom-left") {
          dX = rawGrowthW / 2;
          dY = -rawGrowthH / 2;
        } else if (anchor === "bottom-right") {
          dX = -rawGrowthW / 2;
          dY = -rawGrowthH / 2;
        }

        state.currentTx += dX;
        state.currentTy += dY;

        el.style.setProperty("--target-scale", nextScale);
        el.style.setProperty("--tx", state.currentTx + "px");
        el.style.setProperty("--ty", state.currentTy + "px");
      });

      // --- MOUSE MOVEMENT ---
      document.addEventListener("mousemove", (e) => {
        if (state.isMobile) return;
        if (state.isLoading) return;

        const cx = e.clientX;
        const cy = e.clientY;

        customCursor.style.left = cx + "px";
        customCursor.style.top = cy + "px";

        let rotation = 0;
        if (state.isZoomed && state.zoomedElement) {
          const rect = state.zoomedElement.getBoundingClientRect();
          if (
            cx >= rect.left &&
            cx <= rect.right &&
            cy >= rect.top &&
            cy <= rect.bottom
          ) {
            const relX = cx - rect.left;
            customCursor.innerHTML =
              relX < rect.width / 2 ? "&larr;" : "&rarr;";
            rotation = 0;
          } else {
            customCursor.innerHTML = "!";
            rotation = 0;
          }
        } else {
          customCursor.innerHTML = "!";
        }
        customCursor.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
        handleTrailLogic(cx, cy);
      });

      document.addEventListener(
        "touchmove",
        (e) => {
          if (e.target.closest("model-viewer") || state.isZoomed) return;
          if (!state.isMobile) return;
          if (state.isLoading) return;
          if (!state.isZoomed) e.preventDefault();
          const touch = e.touches[0];
          const cx = touch.clientX;
          const cy = touch.clientY;
          handleTrailLogic(cx, cy);
        },
        { passive: false }
      );

      document.addEventListener(
        "touchstart",
        (e) => {
          if (e.target.closest("model-viewer") || state.isZoomed) return;
          if (!state.isMobile) return;
          const touch = e.touches[0];
          state.lastX = touch.clientX;
          state.lastY = touch.clientY;
        },
        { passive: true }
      );

      function handleTrailLogic(cx, cy) {
        if (cy < CONFIG.navZoneHeight) return;
        if (state.isZoomed || canvas.classList.contains("hidden-canvas"))
          return;
        if (!state.hasMoved) {
          helperText.style.opacity = "0";
          state.hasMoved = true;
        }
        const dist = Math.hypot(cx - state.lastX, cy - state.lastY);
        const limit = state.isMobile ? CONFIG.mobileMinDist : CONFIG.minDist;
        if (dist > limit) {
          createBox(cx, cy);
          state.lastX = cx;
          state.lastY = cy;
        }
      }

      canvas.addEventListener("click", (e) => {
        const target = e.target.closest(".trail-image");
        if (target && !state.isZoomed) {
          zoomIn(target);
          e.stopPropagation();
          return;
        }
        if (
          state.isZoomed &&
          target &&
          target.classList.contains("zoomed") &&
          !state.isMobile
        ) {
          handleSlideshowClick(e, target);
          e.stopPropagation();
        }
      });

      backdrop.addEventListener("click", zoomOut);
      backdrop.addEventListener(
        "touchstart",
        (e) => {
          if (state.isZoomed) {
            e.preventDefault();
            zoomOut();
          }
        },
        { passive: false }
      );

      function createBox(x, y) {
        if (state.count >= CONFIG.maxImages) return;
        state.count++;
        const boxId = state.count;
        const container = document.createElement("div");
        container.className = "trail-image";

        const width = state.isMobile ? CONFIG.mobileBoxWidth : CONFIG.boxWidth;
        const height = state.isMobile
          ? CONFIG.mobileBoxHeight
          : CONFIG.boxHeight;
        container.style.width = width + "px";
        container.style.height = height + "px";

        // Apply Visual Scale for Mobile (using transform)
        if (state.isMobile) {
          container.style.setProperty("--idle-scale", CONFIG.mobileScale);
        } else {
          container.style.setProperty("--idle-scale", 1);
        }

        const galleryIndex = (state.count - 1) % GALLERIES.length;
        container.dataset.galleryIndex = galleryIndex;
        container.dataset.slideIndex = 0;
        container.dataset.boxId = boxId;

        const coverUrl = GALLERIES[galleryIndex][0];
        loadMedia(
          coverUrl,
          container,
          (el) => {},
          () => {
            container.style.backgroundColor = "#e5e7eb";
            container.style.border = "1px solid #9ca3af";
          }
        );

        container.style.left = `${x}px`;
        container.style.top = `${y}px`;
        container.addEventListener("mouseenter", () => {
          if (!state.isZoomed) {
            const projName = PROJECT_NAMES[boxId - 1] || "";
            if (navCenter) navCenter.innerText = projName;
          }
        });
        container.addEventListener("mouseleave", () => {
          if (!state.isZoomed) {
            resetInfo();
          }
        });
        canvas.appendChild(container);
      }

      function zoomIn(element) {
        state.isZoomed = true;
        state.zoomedElement = element;
        state.currentGalleryIndex = parseInt(element.dataset.galleryIndex);
        state.currentSlideIndex = parseInt(element.dataset.slideIndex);
        updateInfo(parseInt(element.dataset.boxId));

        preloadNeighbors(state.currentGalleryIndex, state.currentSlideIndex);
        document.body.classList.add("zoomed-active");

        const siblings = document.querySelectorAll(".trail-image");
        siblings.forEach((sib) => {
          if (sib !== element) sib.classList.add("faded");
        });

        // MOBILE SCALING
        if (state.isMobile) {
          const vpW = window.innerWidth;
          const currentW = parseFloat(element.style.width);
          const scale = (vpW / currentW) * 1.005;
          state.currentMobileScale = scale;

          const newCenterX = vpW / 2;
          let newCenterY = parseFloat(element.style.top);
          const scaledH = parseFloat(element.style.height) * scale;
          const halfH = scaledH / 2;

          const footerRect = footerEl.getBoundingClientRect();
          const limitBottom = footerRect.top - 10;

          if (newCenterY + halfH > limitBottom) {
            newCenterY = limitBottom - halfH;
          }
          if (newCenterY - halfH < 0) {
            newCenterY = 0 + halfH;
          }

          element.style.left = newCenterX + "px";
          element.style.top = newCenterY + "px";
          element.style.setProperty("--target-scale", scale);
          element.classList.add("zoomed");

          addSwipeListener(element);
          return;
        }

        // DESKTOP SCALING (Initial)
        const canvasW = canvas.offsetWidth;
        const canvasH = canvas.offsetHeight;
        const footerRect = footerEl.getBoundingClientRect();
        const limitBottom = footerRect.top; // Strict Boundary

        const currentW = parseFloat(element.style.width);
        const currentH = parseFloat(element.style.height);
        const halfW = currentW / 2;
        const halfH = currentH / 2;
        const centerX = parseFloat(element.style.left);
        const centerY = parseFloat(element.style.top);

        const distTop = centerY;
        const distBottom = limitBottom - centerY;
        const distLeft = centerX;
        const distRight = canvasW - centerX;

        const sTop = distTop / halfH;
        const sBottom = distBottom / halfH;
        const sLeft = distLeft / halfW;
        const sRight = distRight / halfW;

        const finalScale = Math.min(sTop, sBottom, sLeft, sRight);
        state.currentScale = finalScale;
        state.initialScale = finalScale; // SAVE initial for reset
        state.currentTx = 0;
        state.currentTy = 0;

        // Identify Anchor
        let anchor = "";
        if (Math.abs(finalScale - sTop) < 0.01) anchor = "top";
        else if (Math.abs(finalScale - sBottom) < 0.01) anchor = "bottom";
        else if (Math.abs(finalScale - sLeft) < 0.01) anchor = "left";
        else if (Math.abs(finalScale - sRight) < 0.01) anchor = "right";
        state.anchorEdge = anchor;

        element.style.setProperty("--target-scale", finalScale);
        element.style.setProperty("--tx", "0px");
        element.style.setProperty("--ty", "0px");
        element.classList.add("zoomed");

        navScale.style.display = "block";
      }

      // ... (Rest of Swipe/Slideshow logic unchanged) ...
      function addSwipeListener(element) {
        let touchStartX = 0;
        const handleTouchStart = (e) => {
          touchStartX = e.touches[0].screenX;
          element.classList.add("no-transition");
        };
        const handleTouchMove = (e) => {
          if (!state.zoomedElement) return;
          const touchCurrentX = e.touches[0].screenX;
          const deltaX = touchCurrentX - touchStartX;

          const scale = state.currentMobileScale || 1;
          const effectiveDelta = deltaX / scale;

          element.style.transform = `translate(-50%, -50%) scale(var(--target-scale)) translateX(${effectiveDelta}px)`;
        };
        const handleTouchEnd = (e) => {
          element.classList.remove("no-transition");
          const touchEndX = e.changedTouches[0].screenX;
          const deltaX = touchEndX - touchStartX;
          element.style.transform = "";
          if (deltaX < -50) changeSlide(1);
          else if (deltaX > 50) changeSlide(-1);
          element.removeEventListener("touchmove", handleTouchMove);
        };
        element.addEventListener("touchstart", handleTouchStart, {
          passive: true,
        });
        element.addEventListener("touchmove", handleTouchMove, {
          passive: false,
        });
        element.addEventListener("touchend", handleTouchEnd, { passive: true });
      }

      function handleSlideshowClick(e, element) {
        // Removed blocking check for instant skipping
        const rect = element.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const width = rect.width;
        if (clickX > width / 2) changeSlide(1);
        else changeSlide(-1);
      }

      function changeSlide(direction) {
        if (!state.zoomedElement) return;

        // Immediately update index so repeated clicks work
        const gallery = GALLERIES[state.currentGalleryIndex];
        let nextIdx = state.currentSlideIndex + direction;
        if (nextIdx >= gallery.length) nextIdx = 0;
        if (nextIdx < 0) nextIdx = gallery.length - 1;

        state.currentSlideIndex = nextIdx;
        state.zoomedElement.dataset.slideIndex = nextIdx;

        // Clear existing loader timeout
        if (state.loaderTimeout) clearTimeout(state.loaderTimeout);
        // Remove existing loader
        const existingLoader =
          state.zoomedElement.querySelector(".slide-loader");
        if (existingLoader) existingLoader.remove();

        // 300ms Delay for Loader
        const myIndex = nextIdx; // Capture index for closure
        state.loaderTimeout = setTimeout(() => {
          // Only show if we are still on this index (basic check)
          if (state.currentSlideIndex === myIndex) {
            const loader = document.createElement("div");
            loader.className = "slide-loader";

            const scale = getComputedStyle(
              state.zoomedElement
            ).getPropertyValue("--target-scale");
            if (scale)
              loader.style.transform = `translate(-50%, -50%) scale(${
                1 / parseFloat(scale)
              })`;

            loader.innerHTML = `
                   <div class="loading-rect"></div>
                   <div class="loading-rect"></div>
                   <div class="loading-rect"></div>
                   <div class="loading-rect"></div>
                 `;
            state.zoomedElement.appendChild(loader);
          }
        }, 300);

        const url = gallery[nextIdx];

        loadMedia(
          url,
          state.zoomedElement,
          (newEl) => {
            // Success
            // Check if this image matches the CURRENT index
            // This handles rapid clicking by discarding stale loads
            if (state.currentSlideIndex !== nextIdx) {
              newEl.remove();
              return;
            }

            if (state.loaderTimeout) clearTimeout(state.loaderTimeout);
            const loader = state.zoomedElement.querySelector(".slide-loader");
            if (loader) loader.remove();

            // INSTANT SWAP
            const oldSlides =
              state.zoomedElement.querySelectorAll(".slide-image");
            oldSlides.forEach((el) => {
              if (el !== newEl) el.remove();
            });

            preloadNeighbors(state.currentGalleryIndex, nextIdx);
          },
          () => {
            // Error handling
            if (state.currentSlideIndex === nextIdx) {
              changeSlide(direction); // Skip to next if fail
            }
          }
        );
      }

      function zoomOut() {
        state.isZoomed = false;
        state.zoomedElement = null;
        resetInfo();
        navScale.style.display = "none";
        document.body.classList.remove("zoomed-active");
        const zoomedEl = document.querySelector(".trail-image.zoomed");
        if (zoomedEl) {
          zoomedEl.classList.remove("zoomed");
          zoomedEl.style.removeProperty("--tx");
          zoomedEl.style.removeProperty("--ty");
          setTimeout(() => {
            if (zoomedEl) zoomedEl.style.removeProperty("--target-scale");
          }, 500);
        }
        const fadedEls = document.querySelectorAll(".trail-image.faded");
        fadedEls.forEach((el) => el.remove());
        setTimeout(() => {
          if (zoomedEl) zoomedEl.remove();
          const allImages = document.querySelectorAll(".trail-image");
          allImages.forEach((img) => img.remove());
          state.count = 0;
          state.hasMoved = false;
          state.lastX = 0;
          state.lastY = 0;
          helperText.style.opacity = "1";
        }, 550);
      }
    </script>
  </body>
</html>
